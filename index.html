<!DOCTYPE html>
<html>
  <head>
    <title>STL</title>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/STLLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://threejs.org/examples/js/objects/Reflector.js"></script>
    <script src="https://threejs.org/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <style>
      body {
        overflow: hidden;
        margin: 0;
        position: relative;
      }
      .colorpick{
        display: flex;
        align-items: flex-start;
        gap :10px;
        flex-direction: column;
        position: absolute;
        width: 100%;
      }
      .colorClass {
        width: 100px;
        height: 30px;
        margin: 10px;
        z-index: 999;
        position: relative;
      }
      .first{
        background-color: #ff0000;
      }
      .sec{
        background-color: #0000ff;
      }
      .third{
        background-color: #1e2ce2;

      }
    </style>
  </head>
  <body>
    <input type="file" id="loadStl" accept=".stl" /><br />
    <input id="resultField" /><br /><br />
    Instant Quote : <input id="volume" /><br /><br />
    <div class="colorpick">
      wax <div class="colorClass first" onclick='changeMaterial("wax")' ></div>
      X-one resin <div class="colorClass sec" onclick='changeMaterial("X-one resin")' ></div>
    </div>
    <script>
      var volume, quote;
      var newColor = '0xf0f0f';
      var mesh;
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.setScalar(5);
      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(0xeeeeee);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      const light = new THREE.AmbientLight( 0x404040 ); // soft white light
      scene.add( light );

      const NewSpotlight = new THREE.SpotLight(0x0dfe6e9, .2);
      NewSpotlight.castShadow = true;
      NewSpotlight.position.set(-50, -100, 50);
      scene.add(NewSpotlight);
      scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

      spotlight = new THREE.SpotLight(0x0dfe6e9, .3);
      spotlight.castShadow = true;
      spotlight.position.set(100, 100, 20);
      scene.add(spotlight);

      const sun = new THREE.DirectionalLight(0xffffcc)
      sun.position.set(0, 1, 0)
      scene.add(sun)

      // const loader = new THREE.TextureLoader();
      // const planeSize = 40;
      // const texture = loader.load('https://r105.threejsfundamentals.org/threejs/resources/images/checker.png');
      // texture.wrapS = THREE.RepeatWrapping;
      // texture.wrapT = THREE.RepeatWrapping;
      // texture.magFilter = THREE.NearestFilter;
      // const repeats = planeSize / 2;
      // texture.repeat.set(repeats, repeats);

      // const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
      // const planeMat = new THREE.MeshBasicMaterial({
      //   map: texture,
      //   side: THREE.DoubleSide,
      // });
      // planeMat.color.setRGB(1, 1, 1);
      // const planeMesh = new THREE.Mesh(planeGeo, planeMat);
      // planeMesh.rotation.x = Math.PI * -.5;
      // // planeMesh.position.z -= 20
      // scene.add(planeMesh);
      
      scene.add(new THREE.HemisphereLight(0xffffff, 1.5));
      const size = 100;
      const divisions = 100;
      const gridHelper = new THREE.GridHelper( size, divisions );
      scene.add( gridHelper );

      // let geo, material;

      // geo = new THREE.PlaneBufferGeometry( 100, 100 );
      // groundMirror = new THREE.Reflector( geo, {
      //   clipBias: 0.001,
      //   textureWidth: window.innerWidth * window.devicePixelRatio,
      //   textureHeight: window.innerHeight * window.devicePixelRatio,
      //   color: 0xaaaaaa,
      // } );
  
      // groundMirror.rotateX( - Math.PI / 2 );
      // scene.add( groundMirror );

      var controls = new THREE.OrbitControls(camera, renderer.domElement);

      const loadStl = document.querySelector("#loadStl");
      loadStl.addEventListener("change", function () {
        const reader = new FileReader();
        reader.addEventListener("load", () => {
          var loader = new THREE.STLLoader();
          loader.load(reader.result, function (geometry) {
            const mergedGeometry = new THREE.BufferGeometryUtils.mergeVertices(geometry, 0.01);
            mergedGeometry.computeVertexNormals();
            geometry = mergedGeometry;
            geometry.computeVertexNormals();

            // var geo = new THREE.BufferGeometryUtils.mergeVertices(geometry);
            mesh = new THREE.Mesh(
              geometry,
             new THREE.MeshPhysicalMaterial({
              color: 0xd4af37,
              emissive: 0x222222,
              metalness: 1, 
              wireframe: false,
              roughness: 0.5,
              reflectivity:1.0,
              specular: 100, 
              shininess: 100,
              flatShading: false})
            );

            mesh.rotation.set(-Math.PI / 2, 0, 0);
            mesh.scale.setScalar(0.1);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            volume = getVolume(geometry) ;
            document.querySelector("#resultField").value =
              "stl volume is " + getVolume(geometry);
          });
        });
        reader.readAsDataURL(this.files[0]);
      });

      // check with known volume:
      var hollowCylinderGeom = new THREE.LatheBufferGeometry(
        [
          new THREE.Vector2(1, 0),
          new THREE.Vector2(2, 0),
          new THREE.Vector2(2, 2),
          new THREE.Vector2(1, 2),
          new THREE.Vector2(1, 0),
        ],
        90
      ).toNonIndexed();
      console.log(
        "pre-computed volume of a hollow cylinder (PI * (R^2 - r^2) * h): " +
          Math.PI * (Math.pow(2, 2) - Math.pow(1, 2)) * 2
      );
      console.log(
        "computed volume of a hollow cylinder: " + getVolume(hollowCylinderGeom)
      );

      function changeMaterial(material){
        switch (material) {
          case "wax":
            quote = volume * 13.5;
            color = "#ff0000"
            break;
          case "X-one resin":
            color = "#0000ff"
            quote = volume * 1.01;
          break;
        }
        var rgbcolor = hexToRgbA(color);
        mesh.material.color.set(rgbcolor);
        document.querySelector("#volume").value = quote;
        // console.log('aaaaaa',mesh.material.color)
      }

      const hexToRgbA = (hex) =>{
        var c;
        if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
            c= hex.substring(1).split('');
            if(c.length== 3){
                c= [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c= '0x'+c.join('');
            return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+',1)';
        }
        throw new Error('Bad Hex');
      }

      function getVolume(geometry) {
        let position = geometry.attributes.position;
        let faces = position.count / 3;
        let sum = 0;
        let p1 = new THREE.Vector3(),
          p2 = new THREE.Vector3(),
          p3 = new THREE.Vector3();
        for (let i = 0; i < faces; i++) {
          p1.fromBufferAttribute(position, i * 3 + 0);
          p2.fromBufferAttribute(position, i * 3 + 1);
          p3.fromBufferAttribute(position, i * 3 + 2);
          sum += signedVolumeOfTriangle(p1, p2, p3);
        }
        sum = Math.round(sum) / 1000
        return sum;
      }

      function getRandomColor() {
        var letters = "0123456789ABCDEF";
        var color = "#";
        for (var i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      function setRandomColor() {
        var color = getRandomColor();
        $("#colorpad1").css("background-color", color);
        document.querySelector("#colorValue1").value =
          "Random color : " + color;
        newColor = color;
      }

      function signedVolumeOfTriangle(p1, p2, p3) {
        return p1.dot(p2.cross(p3)) / 6.0;
      }

      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });
    </script>
  </body>
</html>
